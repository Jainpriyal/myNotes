GIT Configuration:
    System level: git config --system
    user level: git config --global
    project level: git config
    
    git config --user.name "pritesh ranjan"
    git config --user.email "priteshranjantrivedi@gmail.com"
    git config --list
    git config user.email
    git config --global core.editor "vim"
    git config --global color.ui true

GIT Auto-Completion: Look on web, how to configure in linux. Already available in windows
Initializing a repository:
git init 
git add  # Have to do this every time, before a commit
git commint -m "first commit"  # Always write commit message in present tense
git commit -a -m "Commits by taking a shortcutting git stage step. Don't use this"  
git status
git log  
git log -n 2  # returns the 2 latest commits
git log --since=2016-01-10
git log --until=2016-01-10
git log --author="pritesh"
git log --grep="initial"

head information in ./.git/HEAD which refers to ./.git/refs/heads/master
View the changes in the working directory:
git diff 
git diff filename
git diff --color-words filename  # nice word by word diffs
view the changes in the staging area:
git diff --staged   (--cached in versions earlier than v1.6, also available in newer version)

Deleting files:
STEP_1> git rm filename.txt  # this will completely delete the file and add that to the staging area/index
git 
STEP_2> git commit -m "i will find you and i will kill you"

Moving and renaming files:
git mv abc.txt def.txt
git commit -m "good luck"  # NOTE: if you delete/move the file directly using OS, then stage them yourself. 

Undoing working directory changes:
git checkout -- filename or directoryname  # -- makes sure that you are checking out files and/or directories in THE CURRENT BRANCH. It's helpful when some filename and directoryname are same as a branch.

Unstaging files:
git reset HEAD filename  

Amending commits:
Can only change the latest commit (for obvious reasons - because there are no other commits that refer to this).
git commit --amend -m "new message"

Retrieving old versions:
git checkout SHA_of_the_commit -- filename  # -- for current branch

Reverting a commit:
git revert revert SHA_of_the_commit_that_is_to_be_reverted  # This will automatically commit the change also. use -n (--no-commit) if you want to commit yourself. 
REMEMBER : revert is good only when changes are simple. Use merge for complex changes.

Using Reset to undo commits: (it's dangerous)
REMEMBER : Keep a copy of all the commit SHA in a separate file, before you fire a reset command. Because after a reset SHA after that reset commit are not sho
Reset moves the HEAD pointer back in the commit chain. If you do any changes it shall override the other commits that had been done after that particular commi
* Soft reset: Just moves the HEAD, but doesn't change the staging index or working directory.
* mixed (default) reset: changes staging index to match repository. Doesn't change working directory.
* hard reset: changes staging index and working directory to match directory.

git reset --soft SHA_of_the_commit_to_which_you_want_to_reset
git reset --mixed SHA_of_the_commit_to_which_you_want_to_reset
git reset --hard SHA_of_the_commit_to_which_you_want_to_reset

Removing untracked files: (other than just deleting them directly from OS.) NOTE: On windows, it wouldn't even go in recycle bin. It will be totally trashed. 
* git clean -f  # give -n option to see what all files will be deleted.

Ignoring files in our project repository
.gitignore
* very basic regular expressions
    e.g. [aeiou][0-9]
    *.php
* negate expressions with !
    !index.php
* # starts a comment
log/*.log 
log/*.log.[0-9]
==> It's a good idea to ignore these type of files: Compiled source code, Zipped Files, Logs and DB files, OS generated files, user-uploaded assets

Ignoring files globally
git config --global core.excludesfile ~/.gitignore_global

Ignoring tracked files: 
$> git rm --cached filename
$> git commit -m ""