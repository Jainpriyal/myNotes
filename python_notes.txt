python 2.7 
REMEMBER: / is integer division in 2.7.  In 3.5. / float division and  // is integer division.
from __future__ import division
raw_input()  # NOTE: raw_input is not available in 3.5.1 (or 3.X)
input()  # Equivalent to eval(raw_input(prompt))
divmod(x, y) -> (quotient, remainder)
pow(x, y[, z]) -> number # With two arguments, equivalent to x**y.  With three arguments, equivalent to (x**y) % z, but may be more efficient (e.g. for longs).
range(start, stop[, step]) -> list of integers  # in python 2.7
range(start, stop[, step]) -> range object  # python 3.5
xrange(start, stop[, step]) -> xrange object  # similar to range in 3.5  # NOTE: xrange doesn't exist in 3.5. So avoid using it.
getattr(object, name[, default]) -> value  # http://stackoverflow.com/questions/4075190/what-is-getattr-exactly-and-how-do-i-use-it

join(list [,sep]) -> string  # string.join method in string is no more. Instead use 'seperator'.join(iterable) -> string

Diff between eval and exec  # TL;DR http://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile-in-python
hash(object) -> integer  # Two objects with the same value have the same hash value.  The reverse is not necessarily true, but likely. # hash(1) == hash(1.0)

myset.add(...)  # will take only hashable object
myset.update(...)  # will take only iterable objects
myset.remove(...)  # If the element is not a member, raise a KeyError.
myset.discard(...)  # If the element is not a member, do nothing.
myset.union, intersection, difference, symmetric_difference
myset.update, myset.intersection_update, myset.difference_update, myset.symmetric_difference_update
set >= otherSet 

Sort a list by multiple attributes?  # http://stackoverflow.com/questions/4233476/sort-a-list-by-multiple-attributes

''.ljust(), ''.rjust(), ''.center()
'BANANA FRIES 12'.rpartition(' ')  --> ('BANANA FRIES', ' ', '12')
'BANANA FRIES 12'.rsplit(sep=' ', maxsplit=1)  --> ['BANANA FRIES', '12']
print "{:.2f}".format(4.00001)  # Go through this TL;DR https://pyformat.info/

import textwrap 
textwrap.fill()   
textwrap.wrap()

print ("{0:o}, {0:X}, {0:b}, {0:d}".format(34)) # prints 34 in octal, hex, binary, and decimal # output # 42, 22, 100010, 34

builtins => chr, ord  # do help(chr) 

NOTE: 'Hello   World  Lol'.split(' ') vs 'Hello   World  Lol'.split(' ') # there is a difference, the first one creates extra blank elements also from the spaces between words

itertools.product # Cartesian product of input iterables.  Equivalent to nested for-loops.
itertools.permutations  # permutations([1,2,3], 2) --> (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)
itertools.combinations #  combinations(range(4), 3) --> (0,1,2), (0,1,3), (0,2,3), (1,2,3)
itertools.combinations_with_replacement  # combinations_with_replacement('ABC', 2) --> AA AB AC BB BC CC
itertools.groupby # https://docs.python.org/2/library/itertools.html#itertools.groupby

collections.Counter #  https://pymotw.com/2/collections/counter.html
collections.defaultdict 
collections.namedtuple
collections.OrderedDict
collections.deque()

any(), all()
print [Ram, Rahim][False/True]  # Ram if False else Rahim
map
reduce(lambda x,y:  x+y, ['a', 'b', 'c'])  # will return 'abc'

re.search(r"ly", 'similarily')
asd = re.match(r"ly", "lysafdf")
asd.group()
asd.groups()
re.split("-","+91-011-2711-1111")
>>> m = re.match(r'(?P<user>\w+)@(?P<website>\w+)\.(?P<extension>\w+)','myname@hackerrank.com')
>>> m.groupdict()
{'website': 'hackerrank', 'user': 'myname', 'extension': 'com'}


REGEX: re # "To be proficient in Regex" -> My new year's resolution for the past 4 years
p = re.compile(r'pattern')  # The backslash-plague https://docs.python.org/2/howto/regex.html#the-backslash-plague
m = p.match('string')
m = p.search('string')
m = p.findall('string)
m = p.finditer('string')
m.group(), m.groups(), m.start(), m.end(), m.span()
https://docs.python.org/2/howto/regex.html#module-level-functions and I agree to this "I generally prefer to work with the compiled object, even for one-time uses, but few people will be as much of a purist about this as I am."
Compilation Flags https://docs.python.org/2/howto/regex.html#compilation-flags
Non Capturing and Named Groups https://docs.python.org/2/howto/regex.html#non-capturing-and-named-groups
Look ahead assertions https://docs.python.org/2/howto/regex.html#lookahead-assertions

https://docs.python.org/2/howto/regex.html#splitting-strings
Sometimes you’re not only interested in what the text between delimiters is, but also need to know what the delimiter was. If capturing parentheses are used in the RE, then their values are also returned as part of the list. Compare the following calls:

>>>
>>> p = re.compile(r'\W+')
>>> p2 = re.compile(r'(\W+)')  # Note the parentheses here
>>> p.split('This... is a test.')
['This', 'is', 'a', 'test', '']
>>> p2.split('This... is a test.')
['This', '... ', 'is', ' ', 'a', ' ', 'test', '.', '']

Common Problems: https://docs.python.org/2/howto/regex.html#common-problems

Lookahead and lookbehind asseertions: http://www.rexegg.com/regex-lookarounds.html
"With lookarounds, your feet stay planted on the string. You're just looking, not moving!"
Lookaround	Name	                What it Does
(?=foo)	    Lookahead	            Asserts that what immediately follows the current position in the string is foo
(?<=foo)	Lookbehind	            Asserts that what immediately precedes the current position in the string is foo
(?!foo)	    Negative Lookahead	    Asserts that what immediately follows the current position in the string is not foo
(?<!foo)	Negative Lookbehind	    Asserts that what immediately precedes the current position in the string is not foo

